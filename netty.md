# netty notes

## 内存复制概念

- fd
  - linux 一切皆文件的哲学
  - 文件索引 就是 文件描述符
- 进程
  - 系统为一个进程分配一个0~4G的虚拟地址空间
  - 1G为内核空间
  - 3G为用户空间
- 页表（虚拟地址 和 物理地址的映射）
- 内核空间
  - 受保护的内存空间、底层硬件访问权限、所有进程共享
- 用户空间
  - 危险的指令需要权限。用户虚拟地址空间
- **IO操作**
  - **都是通过内核空间进行操作。由内核提供的接口完成。**
  - **用户程序需要调用接口**
  - **用户态切换成内核态**
  - **内核态从IO中读取数据到内核空间内存**
  - **拷贝内核内存到用户内存当中**
  - **切换回用户态**
  - **拷贝一般是指缓冲数据拷贝，内核缓冲->用户缓冲 或者倒转**
- 用户态
- 内核态
- 进程的堆栈
  - Linux 中每个进程有两个栈，分别用于用户态和内核态。
- 设备的等待队列

## 有缓冲的IO事件

- 流
  - 读取和写入描述符数据的对象
- 缓冲buf
  - 不同的读写速度
  - 减少频繁操作流，一般数据是一行一行读取，所以操作相当频繁。但是缓冲完成后，这个操作就是在内存中操作了。
- 内核缓冲区
- 用户缓冲区
- 事件
  - 可以认为是一个事情发生了，然后这个事情状态要通知别人
- IO事件
  - 内核缓冲区非空事件
    - 管道写入，产生事件，通知读者
  - 内核缓冲区满事件
    - 就是缓冲区已经满了，写入方就会收到通知，并且阻塞
  - 内核缓冲区非满事件
  - 内核缓冲区空事件
    - 通知读取方，不要再读取了。相当于阻塞。

## netty 零拷贝

- os的零拷贝
  - mmap
    - 将用户空间的一段映射到内核空间
    - 操作这段空间，用户态和内核态之间不需要切换
- netty的零拷贝
  - java用户空间层面的。
  - CompositeByteBuf 两个buf合并，其实还是单独的，只是操作合并在一起了。
  - directbuffer
    - 直接内存保存->切换内核态->复制到内核内存->调用socket io操作
    - 堆内存操作IO
      - JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。
  - Unpooled.wrappedBuffer(bytes); bytes数组不拷贝
  - FileChannel.transferTo
    - while ((length = in.read(temp)) != -1) 方式，temp数组不断复制
    - transferTo 没有temp复制的过程。

## nio概念

- bio
  - 一个线程对应一个监管IO事件。多个IO，也就多个线程。
- nio2/aio
  - java7 nio
- I/O多路复用机制
  - 单线程监控channel（文件描述符，IO，socket），减少多线程机制上下文切换
  - 监控读写状态，是否准备好。
- selector
  - 忙轮询所有用到的描述符（所有channels，sockets）
  - 忙是指线程空闲不阻塞，可能导致空轮询
  - 忙轮询
  - O(n)线程复杂度
  - 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大
  - 同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大
  - select支持的文件描述符数量太小了，默认是1024
- poll
  - poll没有最大文件描述符数量的限制
  - 线程空闲阻塞，有IO事件则唤醒
  - 无差别轮询
  - O(n)
- epoll
  - poll基础上，轮询对象变成就绪状态的文件描述符。
  - linux内核初始化后，内核高速cache
  - 需要监控的红黑树sockets保存到cache中
  - IO事件轮询
  - O(1)/O(k)
  - epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。
  - epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）**并为每个fd指定一个回调函数**，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个**回调函数会把就绪的fd加入一个就绪链表**）。

## boss 和 worker

- boss 线程池 负责 accept
- worker 线程池 负责 read/write
